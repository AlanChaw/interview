
1. 二叉树(BST)和哈希表的优缺点对比与选择
    - 哈希表优点：插入和查找时间复杂度O(1)。缺点在于可能会发生冲突，发生冲突时时间复杂度可能会降低到 O(n)。而且一旦 resize 成本是很高的，有可能扩展后所有数都要 rehash。
    - 二叉树优点：不会发生冲突。插入和查找一直是 O(logn)。而且二叉树是有序的。
    - 选择：当提前能够预知数据大小时，而且无需排序时，可以选哈希表。但如果数据要持续加入，预先不知道大小，二叉树更好。

2. 解决哈希冲突的常用方法
    - __开放定址法（开散列）__：从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。然后把发生冲突的元素存入到该单元的一种方法。开放定址法需要的表长度要大于等于所需要存放的元素。
    在开放定址法中解决冲突的方法有：__线行探查法__、__平方探查法__、__双散列函数探查法__。
        开放定址法的缺点在于删除元素的时候不能真的删除，否则会引起查找错误，只能做一个特殊标记。只到有下个元素插入才能真正删除该元素。

        - __线性探查法__：它从发生冲突的单元起，依次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探查完全部单元为止。

        - __平方探查法__：平方探查法即是发生冲突时，用发生冲突的单元d[i], 加上 1²、 2²等。即d[i] + 1²，d[i] + 2², d[i] + 3²...直到找到空闲单元。

        - __双散列函数探查法__：对于双散列函数探查法，其探查序列的步长值是同一关键字的另一散列函数的值。

    - __拉链法（闭散列）__：链接地址法的思路是将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。

    - __再哈希法__：就是同时构造多个不同的哈希函数,当H1 = RH1(key) 发生冲突时，再用H2 = RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。

    - __公共溢出区__：将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。

3. STL 中的 hash_table。
    - hash_set、hash_map、hash_multiset、hash_multimap四个关联容器都是以hashtable为底层实现方法。通过开链法实现，hash table表格内的元素称为桶（bucket),而由桶所链接的元素称为节点（node),其中存入桶元素的容器为stl本身很重要的一种序列式容器——vector容器。

    - 虽然开链法并不要求表格大小必须为质数，但SGI STL仍然以质数来设计表格大小，并且将28个质数（逐渐呈现大约两倍的关系）计算好，以备随时访问，同时提供一个函数，用来查询在这28个质数之中，“最接近某数并大于某数”的质数。

4. STL 的 rehash 和 Redis 的 rehash 对比
    - STL: 模仿C++的vector扩容方式，Hash表中每次发现loadFactor==1时，就开辟一个原来桶数组的两倍空间（称为新桶数组），然后把原来的桶数组中元素全部转移过来到新的桶数组中。注意这里转移是需要元素一个个重新哈希到新桶中的。

    - Redis: 

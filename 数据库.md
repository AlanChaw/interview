1. CAP 原理的解释
    > 一个分布式系统里面，节点组成的网络本来应该是连通的。然而可能因为一些故障，使得有些节点之间不连通了，整个网络就分成了几块区域。数据就散布在了这些不连通的区域中。这就叫分区。当你一个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据了。这时分区就是无法容忍的。提高分区容忍性的办法就是一个数据项复制到多个节点上，那么出现分区之后，这一数据项就可能分布到各个区里。容忍性就提高了。然而，要把数据复制到多个节点，就会带来一致性的问题，就是多个节点上面的数据可能是不一致的。要保证一致，每次写操作就都要等待全部节点写成功，而这等待又会带来可用性的问题。总的来说就是，数据存在的节点越多，分区容忍性越高，但要复制更新的数据就越多，一致性就越难保证。为了保证一致性，更新所有节点数据所需要的时间就越长，可用性就会降低。

2. Redis
    - 类型：string、list、hash、set
    - 渐进式哈希
    - 持久化： 保存快照、AOF(存储写命令并恢复)
    - 单线程，非阻塞IO + IO多路复用
    - 主从架构 - Master-Slave, 可用性、最终一致性
    - 哨兵系统，提供主备转换

3. 缓存雪崩
    - 大量缓存同时失效，大量请求都到了数据库中
    - 或Redis挂掉导致请求都走数据库
    - 解决
        - 在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期
        - 对Redis挂掉的情况，（实现主从架构和哨兵系统，尽量避免挂掉），做Redis持久化，快速进行恢复。

4. 缓存穿透
    - 查询一个一定不存在的数据，导致请求一定会穿透到数据库
    - 解决： 
        - 提前拦截（布隆过滤器） 
        - 我们从数据库找不到的时候，我们也将这个空对象设置到缓存里边去。下次再请求的时候，就可以从缓存里边获取了。这种情况我们一般会将空对象设置一个较短的过期时间。

5. 缓存与数据库双写一致
    - 读操作：如果缓存有就读缓存、缓存没有会先去查询数据库，然后将数据库查出来的数据写到缓存中。
    - 双写一致：数据库和缓存中数据不一致。
    - 对于更新操作：
        - 一般更新数据库后，都直接删除缓存，而不是更新缓存。
        - 方案一：先更新数据库，再删除缓存。在高并发下表现优异，在原子性被破坏时表现不如意
        - 方案二：先删除缓存，再更新数据库。在高并发下表现不如意，在原子性被破坏时表现优异
        - 一般解决方案：将删除缓存、修改数据库、读取缓存等的操作积压到队列里边，实现串行化。

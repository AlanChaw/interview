* **一.理论**
    - **1.进程与线程**
        - 1）进行间通信的方式？([管道](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#31-%E7%AE%A1%E9%81%93)、[消息](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#32-%E6%B6%88%E6%81%AF)、[共享内存](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#33-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98)、[信号量](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#12-%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%94%AF%E6%8C%81)、[信号](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#35-%E4%BF%A1%E5%8F%B7)、套接字)
            > - 管道：管道是一个环形缓冲区，允许两个进程以生产者/消费者的模型进程通信。操作系统强制执行互斥，一次只有一个进程能访问管道。分为命名管道和匿名管道，命名管道允许不相关进程进行通信，匿名管道只有有亲缘关系的进程才能共享。
            > 
            > - 消息队列：消息的链表。每个进程都有一个关联的消息队列，功能类似于信箱。
            > - 共享内存：UNIX提供的进程间通信手段中速度最快的一种。共享内存是虚存中由多个进程共享的一个公共内存块。互斥约束不属于共享内存机制的一部分，但必须由使用共享内存的进程提供
            > - 信号量：信号量是用来调协进程对共享资源的访问的。信号量是一个特殊的变量，程序对其访问都是原子操作，且只允许对它进行等待（即P(信号变量))和发送（即V(信号变量))信息操作。
            > - 信号：signal，程序可用使用signal函数来处理指定的信号，例如SIGUSR信号用来在进程间通信。
            > - Socket：例如TCP或UDP，常用于不在同一个机器上的进程间的通信。

        - 2）[进程和线程的区别联系](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#1%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B)？(组成、效率、通信、安全性)
            > - 进程是操作系统进行资源分配的基本单位，线程是调度的基本单位，是进程的一部分。进程拥有资源，线程只能访问所属进程的资源。
            > 
            > - 线程的创建和终止开销较小，而且同一个进程内线程切换不会引起进程的切换，效率较高。
            > - 线程间通信可以通过直接读写同一进程中的数据进行通信，无需调用内核。而进程监听通信往往需要内核介入，以保护通信所需要的机制。
            > - 线程之间由于内存没有保护，一个线程可以读写另一个线程的内存，所以安全性要差一些。

        - 3）为什么线程调度开销比进程调度更小？
            > CPU执行任务调度的开销，主要是进程上下文切换的开销。任务调度后，CPU Cache/TLB不命中，导致缺页中断的开销

        - 4）[进程的地址空间布局](https://blog.csdn.net/yusiguyuan/article/details/45155035)
            > 由低地址到高地址：程序段（text）、初始化过的数据（data）、未初始化的数据（BSS）、栈、堆。Text, BSS, Data段在编译时已经决定了进程将占用多少虚拟内存。
        
        - 5）内核空间和用户空间
            > Linux系统对自身进行了划分，一部分核心软件独立于普通应用程序，运行在较高的特权级别上，它们驻留在被保护的内存空间上，拥有访问硬件设备的所有权限，Linux将此称为内核空间。

        - 7）程序状态字(PSW)？（一个或一组处理器寄存器，包含有进程的状态信息）
            > 又称状态寄存器，主要用于反映处理器的状态及某些计算结果以及控制指令的执行。

        - 7）进程[创建的步骤](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#21-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%BB%88%E6%AD%A2)？
            > - 分配进程标识符、分配空间、初始化进程控制块。
            
        - 8）进程切换和线程切换的步骤？
            > 1. 切换页目录以使用新的地址空间
            > 2. 切换内核栈
            > 3. 切换硬件上下文
            > - 进程切换需要123，切换后可能会导致缺页，所以开销较大。线程切换只需要23.

        - 9）进程控制块PCB
            > 当一个进程被创建时PCB就被分配，然后有关进程的所有信息就全都存储在PCB中，例如，打开的文件，页表基址寄存器，进程号等等。在linux中PCB是用结构task_struct来表示的

        - 10）[线程分配什么？TCB(线程控制块)?](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#1%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B)
            > 线程自己的线程栈和线程控制块。

        - 11）[线程共享进程的什么？不共享什么？CPU共享吗？](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#1%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B)
            > - 共享：进程代码段、进程公有数据、打开的fd、信号处理器、进程用户ID和进程组ID
            > - 线程独立的资源：线程自身ID、寄存器中的值、自身的函数堆栈等等。所以CPU是不共享的。

        - 12）怎样保证一个CPU只有一个线程运行？（[CPU核数与多线程](https://blog.csdn.net/qq_33530388/article/details/62448212)）
            > ??? 一个CPU在同一时刻只能有一个线程在运行。

        - 13）[线程有什么状态？](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#2%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81)
            > 关键状态有：运行、就绪、阻塞。

        - 14）线程池的了解、优点、调度处理方式和保护任务队列的方式？
            > 由于线程是稀缺资源，不能频繁销毁和创建。因此将线程都放到一个池子中，需要时从中取用，用完后放回。可以使用任务队列为线程池分配任务，类似生产者-消费者模型，池中的每条线程是消费者，从任务队列中获取任务并执行。任务队列可以使用锁来保证线程安全。

        - 15）[怎么回收线程？](../操作系统/UNIX环境高级编程.md#2pthread_join函数)
            > join() 和 detach()。 join()表示等待线程执行结束回收，相当于同步。detach()表示将线程分离，线程对象和线程从此无关。

        - 16）进程->线程->协程[——知乎阿猫](https://www.zhihu.com/question/20511233)（本质好像是[用户态线程](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#3%E7%BA%BF%E7%A8%8B%E5%88%86%E7%B1%BB)，线程与协程最大的区别在是否依赖CPU时钟发出的中断来调度，协程的调度完全由用户控制）

        - 17）[线程与协程的区别](http://www.jianshu.com/p/d058a0fd4ac8)
            > 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

        - 18）[守护进程、僵尸进程、孤儿进程？](http://liubigbin.github.io/2016/03/11/Linux-%E4%B9%8B%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E6%AD%BB%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/)
            > - 守护进程运行在后台，独立于控制终端，周期性执行某种任务，父进程为init，一般系统启动时运行；
            > - 一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。）
            > - 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

        - 19）进程调度方法
            > - 对于批处理系统（没有太多用户操作，保证吞吐量和周转时间即可）
            >   - 先来先服务，FCFS，非抢占，按请求顺序调度。不利于短作业。
            >   - 短作业优先。非抢占，但长作业可能被接连不断的短作业饿死。
            >   - 最短剩余时间优先。抢占式。
            > - 对于交互式系统（需要快速响应用户操作）：
            >   - 轮转调度。使用CPU时间片轮转，但是进程不断切换，开销较大。
            >   - 优先级调度。为了防止优先级低的进程饿死，可以不断提升其优先级。
            >   - 多级队列。每个队列时间片长度1，2，4，8... 若程序在上一个队列未结束，则转到下一队列。
            > - 在Linux中，实时进程优先级最高，会抢占普通进程优先执行。而普通进程使用公平共享调度（CFS），根据NI值设定优先级，分配的不是时间片，而是CPU使用比，按比例获取CPU使用时间。

        - 20）[中断、异常、陷阱和系统调用]
            > - 中断是由外部事件导致并且它发生的时间是不可预测的，这一点和陷阱不同。外部事件主要是指时钟中断（执行时间足够长，CPU切换到另一进程），硬件中断（例如等待用户IO）等。
            > - 异常就是程序执行过程中的异常行为。比如除零异常，缓冲区溢出异常等。异常是在CPU执行指令时本身出现的问题，比如除数为零而出现的除零异常。异常的产生表示程序设计不合理，所以在编程的时候要尽量避免异常的产生。
            > - 陷阱指令可以使执行流程从用户态陷入内核并把控制权转移给操作系统，使得用户程序可以调用内核函数和使用硬件从而获得操作系统所提供的服务，比如用视频软件放一个电影，视频软件就发出陷阱使用显示器和声卡从而访问硬件。

    - **2.并发和死锁**
        - 1）[什么是条件变量？信号量？](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#12-%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%94%AF%E6%8C%81)
            > 信号量：用于进程间传递信号的一个整数值。只有三种操作：初始化、增加（加锁）、减小（解锁）。
            > 互斥量：类似二元信号量，但是加锁和解锁的只能为同一个进程。
            > 条件变量：用于阻塞进程或者线程，直到条件为真。

        - 2）[死锁条件](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#21-%E6%AD%BB%E9%94%81%E7%9A%84%E6%9D%A1%E4%BB%B6)，解决死锁的方法？（[死锁预防](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#22-%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2)、[死锁避免](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#23-%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D)、[死锁检测](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#24-%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B)）
            > - 条件：互斥（资源只能被一个进程使用）、占有和等待、不可抢占、循环等待。
            > - 预防：即在程序运行前做预防。方法：破坏互斥条件（不太现实）、破坏占有和等待条件（进程开始前一次请求所需的全部资源、可能造成浪费）、破坏不可抢占条件（会混乱）、破坏循环等待（按规定顺序请求资源，但不能令所有人都满意）。
            > - 死锁避免：需要提前知道将来进程对资源的请求情况，通过预先计算、确保不会到达死锁点。
            > - 死锁检测和恢复：并不能保证防止死锁，是否死锁要取决于将来同意请求的次序，它所做的一切是确定当前是否存在死锁，然后采取恢复。恢复：取消所有死锁进程、回滚每个死锁进程到前面定义的某些检测点、连续取消死锁进程直到不再存在死锁。

        - 3）互斥和同步？（互斥是对资源独占访问，同步是在互斥基础上通过其它机制实现对资源有序访问）

        - 4）互斥量和信号量的区别？（一个互斥一个同步、值的区别、加锁解锁的线程）
            > - 信号量：多线程同步使用的；一个线程完成某个动作后通过信号告诉别的线程，别的线程才可以执行某些动作；
            > - 互斥量：多线程互斥使用的；一个线程占用某个资源，那么别的线程就无法访问，直到该线程离开，其他线程才可以访问该资源；

        - 5）自旋锁和互斥锁的区别？（失败后的表现，一个忙等一个睡眠）
            > - 自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是 否该自旋锁的保持者已经释放了锁，"自旋"一词就是因此而得名。自旋锁就主要用在临界区持锁时间非常短且CPU资源不紧张的情况下，自旋锁一般用于多核的服务器。
            > - 互斥锁：线程会从sleep（加锁）——>running（解锁），过程中有上下文的切换，cpu的抢占，信号的发送等开销。但不会持续占有CPU。

    - **3.内存管理**
        - 1）[分页](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#3%E5%88%86%E9%A1%B5)（一个进程可以占据多个页，不要求连续，仅最后一页存在内部碎片；[分页中的地址转换](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#31-%E5%88%86%E9%A1%B5%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2)）
            > 由程序产生的虚拟地址先送到MMU，然后MMU根据页表将虚拟地址映射到物理地址。虚拟地址中的内存分块成为页面（page），物理内存中的地址单元成为页框（page frame）。大小通常一样，内存和磁盘间的交换总是以整个页面为单元进行。

        - 2）缺页中断
            > 当软件试图访问已映射在虚拟地址空间中，但是目前并未被加载在物理内存中的一个分页时，由中央处理器的内存管理单元所发出的中断。

        - 3）分段：
            > 当只使用分页时，当有多个动态增加的页表时，一个表可能会和另一个表发生碰撞。所以提供了一种 称为段的地址空间。段的大小是可变的。每个进程都有一个唯一的段表。分段有助于实现保护与共享机制。由于每个段表项包括一个长度和一个基地址，因而程序不会不经意地访问超出该段的内存单元。

        - 4）[缓冲区溢出是什么？会造成什么危害呢？出现原因是什么？](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#51-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA)
            > 缓冲区溢出是指输入到一个缓冲区或者数据保存区域的数据量超过了其容量，从而导致覆盖了其它区域数据的状况。

        - 7）[虚拟内存](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98)（内存管理单元(MMU)：CPU中的一个模块，可以将虚拟地址转换成实际物理地址）
            + 虚拟内存的作用？（程序可以比实际物理内存更大、程序不必完全载入内存即可运行，因此活动进程数更多）
            + 基于[分页](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#1-%E5%88%86%E9%A1%B5)的实现（和不使用虚拟内存相比，页表中多了2个位，一位表示页是否修改，一位表示页是否在内存中、[两级分页系统](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#13-%E4%B8%A4%E7%BA%A7%E5%88%86%E9%A1%B5%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2)）
            + [TLB？](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#15-%E8%BD%AC%E6%8D%A2%E6%A3%80%E6%B5%8B%E7%BC%93%E5%86%B2%E5%8C%BAtlb)（加速页表的访问）
            + 基于[分段](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#2-%E5%88%86%E6%AE%B5)的实现（和不使用虚拟内存相比，段表中多了2个位，一位表示段是否修改，一位表示段是否在内存中）
            + 内存保护（分段有助于内存保护，段表中段的长度描述了段的区域，公共代码可以作为一个段被相同程序的多个进程共享）
            + 基于[段页式](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#3-%E6%AE%B5%E9%A1%B5%E5%BC%8F)的实现
                * 分段对程序员可见、分页对程序员透明
                * 分段有助于扩展性与内存保护、分页有助于消除外部碎片
            + 页面置换算法（目的是尽可能降低缺页错误）：
                > - 最优页面置换算法：只是理论上的算法，很难预测一个页面将来是否会被访问。
                > - 最近最久未使用：LRU。根据过去使用情况，将最近最久未使用的页表换出。
                > - 最近未使用：NRU，每个页面两个状态位R和M，被访问是R=1，被修改时M=1。R位定时清零。优先换出R=0,M=1的脏页。因为R=1的会频繁使用。
                > - 先进先出：FIFO，队列。
                > - 第二次机会：需要换出时不是直接换，而是将其R位由1变0，一旦中途被读取到，则再将R=1。
                > - 时钟（像是timing wheel?）：使用一个环形链表实现。

            + [驻留集](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#44-%E9%A9%BB%E7%95%99%E9%9B%86%E7%AE%A1%E7%90%86)（分配给每个进程的内存大小）管理
                * 驻留集越小，获得进程越多，缺页越高；驻留集越大，活动进程越小，太多时缺页率无明显变化
                * 分配策略与置换范围（固定分配、可变分配、局部置换、全局置换，不存在固定分配全局置换）
            + [清除（写回）策略](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#45-%E6%B8%85%E9%99%A4%E7%AD%96%E7%95%A5)
    - **4.I/O与磁盘调度**
        + 1）[DMA？](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#5%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E5%AD%98%E5%8F%96dma)
        + 2）[I/O缓冲？](../操作系统/操作系统.md#1io缓冲)（输入请求发出之前执行输入，输出请求发出一段时间后才执行输出）
        - 3）[磁盘调度算法](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#22-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95)（FIFO、优先级、SSTF、SCAN、C-SCAN、N-step-SCAN）
* **二.Linux**
    - **1.进程线程**
        + 1）[C程序的存储空间布局](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#3c%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80)
        + 2）[fork vfork clone](temp/进程线程.md#1forkvforkclone)
        + 3）[Linux性能及调优指南：进程管理](http://blog.jobbole.com/105135/)
        + 4）[Linux守护进程启动方法](http://blog.jobbole.com/98657/)
        + 5）[如何实现守护进程](temp/进程线程.md#1如何实现守护进程)
        + 6）[main函数启动之前](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#11-main%E5%87%BD%E6%95%B0)
        + 7）[exit、\_exit、\_Exit](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#1%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E7%BB%88%E6%AD%A2)
        + 8）[线程数量的限制](temp/进程线程.md#1线程数量的限制)
        + 9）[进程数量的限制](temp/进程线程.md#2进程数量的限制)
        + 10）[信号](temp/信号.md#1信号)
        + 11）线程终止的方法？
            * [pthread_exit](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#5pthread_exit%E5%87%BD%E6%95%B0)（主线程调用了`pthread_exit`对其它线程有什么影响？）
            * 线程执行的函数`return`
            * 被同一进程的其它线程调用[pthread_cancel取消线程](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#7pthread_cancel%E5%87%BD%E6%95%B0)
            * 进程main函数`return`或任何线程调用了`exit`、`_Exit`、`exit`
        + 12）[线程与信号](temp/信号.md#2线程与信号)
        + 13）[正确使用waitpid处理终止的子进程](https://github.com/arkingc/note/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B71.md#12-%E4%BD%BF%E7%94%A8waitpid%E7%89%88sig_chld%E5%87%BD%E6%95%B0%E5%A4%84%E7%90%86%E5%AD%90%E8%BF%9B%E7%A8%8Bsigchld%E4%BF%A1%E5%8F%B7)
    - **2.并发**
        + 1）[Linux上分析死锁的简单方法](http://blog.jobbole.com/109743/)
        + 2）进程间通信的主要方式（[管道](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#1%E7%AE%A1%E9%81%93)、[FIFO](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#3fifo)、信号、[消息队列](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#5%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97)、[共享内存](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#7%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8)、[信号量](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#8posix%E4%BF%A1%E5%8F%B7%E9%87%8F)、套接字）
        + 3）[线程间同步的主要方式](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#2%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5)（互斥量、读写锁、条件变量、自旋锁、屏障）
        + 4）[Linux内核同步机制](http://blog.jobbole.com/91784/)
    - **3.文件系统**
        + 1）[Linux中的文件类型](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#2%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B)
        + 2）Linux有哪几种设备？（字符设备与块设备，[mknod系统调用](https://blog.csdn.net/lqp276/article/details/53502992)用来创建设备文件）
        + 3）[如何唯一标识一个设备？](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#13%E8%AE%BE%E5%A4%87%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6)（主设备号和次设备号）
        + 4）[文件描述符的个数](https://blog.csdn.net/yetyongjin/article/details/7476860)
    - **4.I/O**
        + 1）5种I/O模型（[总览](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#%E5%85%AB%E9%AB%98%E7%BA%A7io)）
        + 2）[如何理解阻塞非阻塞与同步异步的区别？](temp/IO.md#2如何理解阻塞非阻塞与同步异步的区别)
        + 3）文件读写使用的系统调用：[open](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#21-%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6)、[close](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#23-%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6)、[lseek](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#24-%E5%AE%9A%E4%BD%8D%E8%AF%BB%E5%86%99%E4%BD%8D%E7%BD%AE)、[read](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#25-%E6%96%87%E4%BB%B6%E8%AF%BB)、[write](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#26-%E6%96%87%E4%BB%B6%E5%86%99)
        + 4）[sync、fsync、fdatasync？](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#5%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5)
        + 5）[文件内存映射mmap](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#6%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84io)（如何使用mmap为文件添加数据？）
    - **5.内存管理**
        + 1）[Linux内存模型](https://www.ibm.com/developerworks/cn/linux/l-memmod/)（内核）
        + 2）[内核内存分配vmalloc与kmalloc](temp/内存管理.md#1内核内存分配)
        + 3）[Linux内核伙伴系统](temp/内存管理.md#二伙伴系统)
        + 4）[slab分配器](temp/内存管理.md#三slab分配器)
        + 5）[Linux内核空间和用户空间是如何划分的？](temp/内存管理.md#1linux内核空间与用户空间是如何划分的)
    - **6.其它**
        + 1）[Linux系统调用](http://gityuan.com/2016/05/21/syscall/)
        + 2）[Linux如何实现系统调用？](temp/系统调用.md#1linux通过什么方式实现系统调用)
        + 3）[Linux中的软中断和工作队列的作用？](temp/进程线程.md#1linux中的软中断和工作队列的作用)
        + 4）[Linux系统中的动态库和静态库](http://blog.jobbole.com/107977/)
        + 5）[Linux Core Dump理解](http://blog.jobbole.com/107760/)
        + 6）[Linux Shell管道命令与重定向命令的区别](http://blog.jobbole.com/93132/)
        + 7）[ioctl函数理解](http://www.cnblogs.com/li-hao/archive/2011/12/22/2297687.html)


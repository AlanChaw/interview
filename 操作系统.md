- **1.进程与线程**
    - 1）进行间通信的方式？([管道](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#31-%E7%AE%A1%E9%81%93)、[消息](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#32-%E6%B6%88%E6%81%AF)、[共享内存](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#33-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98)、[信号量](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#12-%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%94%AF%E6%8C%81)、[信号](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#35-%E4%BF%A1%E5%8F%B7)、套接字)
        > - 管道：管道是一个环形缓冲区，允许两个进程以生产者/消费者的模型进程通信。操作系统强制执行互斥，一次只有一个进程能访问管道。分为命名管道和匿名管道，命名管道允许不相关进程进行通信，匿名管道只有有亲缘关系的进程才能共享。
        > 
        > - 消息队列：消息的链表。每个进程都有一个关联的消息队列，功能类似于信箱。
        > - 共享内存：UNIX提供的进程间通信手段中速度最快的一种。共享内存是虚存中由多个进程共享的一个公共内存块。互斥约束不属于共享内存机制的一部分，但必须由使用共享内存的进程提供
        > - 信号量：信号量是用来调协进程对共享资源的访问的。信号量是一个特殊的变量，程序对其访问都是原子操作，且只允许对它进行等待（即P(信号变量))和发送（即V(信号变量))信息操作。
        > - 信号：signal，程序可用使用signal函数来处理指定的信号，例如SIGUSR信号用来在进程间通信。
        > - Socket：例如TCP或UDP，常用于不在同一个机器上的进程间的通信。

    - 2）[进程和线程的区别联系](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#1%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B)？(组成、效率、通信、安全性)
        > - 进程是操作系统进行资源分配的基本单位，线程是调度的基本单位，是进程的一部分。进程拥有资源，线程只能访问所属进程的资源。
        > 
        > - 线程的创建和终止开销较小，而且同一个进程内线程切换不会引起进程的切换，效率较高。
        > - 线程间通信可以通过直接读写同一进程中的数据进行通信，无需调用内核。而进程监听通信往往需要内核介入，以保护通信所需要的机制。
        > - 线程之间由于内存没有保护，一个线程可以读写另一个线程的内存，所以安全性要差一些。

    - 3）为什么线程调度开销比进程调度更小？
        > CPU执行任务调度的开销，主要是进程上下文切换的开销。任务调度后，CPU Cache/TLB不命中，导致缺页中断的开销

    - 4）[进程的地址空间布局](https://blog.csdn.net/yusiguyuan/article/details/45155035)
        > 由低地址到高地址：程序段（text）、初始化过的数据（data）、未初始化的数据（BSS）、栈、堆。Text, BSS, Data段在编译时已经决定了进程将占用多少虚拟内存。
    
    - 5）内核空间和用户空间
        > Linux系统对自身进行了划分，一部分核心软件独立于普通应用程序，运行在较高的特权级别上，它们驻留在被保护的内存空间上，拥有访问硬件设备的所有权限，Linux将此称为内核空间。

    - 6）程序状态字(PSW)？（一个或一组处理器寄存器，包含有进程的状态信息）
        > 又称状态寄存器，主要用于反映处理器的状态及某些计算结果以及控制指令的执行。

    - 7）进程[创建的步骤](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#21-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%BB%88%E6%AD%A2)？
        > - 分配进程标识符、分配空间、初始化进程控制块。
        
    - 8）进程切换和线程切换的步骤？
        > 1. 切换页目录以使用新的地址空间
        > 2. 切换内核栈
        > 3. 切换硬件上下文
        > - 进程切换需要123，切换后可能会导致缺页，所以开销较大。线程切换只需要23.

    - 9）进程控制块PCB
        > 当一个进程被创建时PCB就被分配，然后有关进程的所有信息就全都存储在PCB中，例如，打开的文件，页表基址寄存器，进程号等等。在linux中PCB是用结构task_struct来表示的

    - 10）[线程分配什么？TCB(线程控制块)?](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#1%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B)
        > 线程自己的线程栈和线程控制块。

    - 11）[线程共享进程的什么？不共享什么？CPU共享吗？](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#1%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B)
        > - 共享：进程代码段、进程公有数据、打开的fd、信号处理器、进程用户ID和进程组ID
        > - 线程独立的资源：线程自身ID、寄存器中的值、自身的函数堆栈等等。所以CPU是不共享的。

    - 12）怎样保证一个CPU只有一个线程运行？（[CPU核数与多线程](https://blog.csdn.net/qq_33530388/article/details/62448212)）
        > ??? 一个CPU在同一时刻只能有一个线程在运行。

    - 13）[线程有什么状态？](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#2%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81)
        > 关键状态有：运行、就绪、阻塞。

    - 14）线程池的了解、优点、调度处理方式和保护任务队列的方式？
        > 由于线程是稀缺资源，不能频繁销毁和创建。因此将线程都放到一个池子中，需要时从中取用，用完后放回。可以使用任务队列为线程池分配任务，类似生产者-消费者模型，池中的每条线程是消费者，从任务队列中获取任务并执行。任务队列可以使用锁来保证线程安全。

    - 15）[怎么回收线程？](../操作系统/UNIX环境高级编程.md#2pthread_join函数)
        > join() 和 detach()。 join()表示等待线程执行结束回收，相当于同步。detach()表示将线程分离，线程对象和线程从此无关。

    - 16）进程->线程->协程[——知乎阿猫](https://www.zhihu.com/question/20511233)（本质好像是[用户态线程](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#3%E7%BA%BF%E7%A8%8B%E5%88%86%E7%B1%BB)，线程与协程最大的区别在是否依赖CPU时钟发出的中断来调度，协程的调度完全由用户控制）

    - 17）[线程与协程的区别](http://www.jianshu.com/p/d058a0fd4ac8)
        > 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

    - 18）[守护进程、僵尸进程、孤儿进程？](http://liubigbin.github.io/2016/03/11/Linux-%E4%B9%8B%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E6%AD%BB%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/)
        > - 守护进程运行在后台，独立于控制终端，周期性执行某种任务，父进程为init，一般系统启动时运行；
        > - 一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。）
        > - 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

    - 19）进程调度方法
        > - 对于批处理系统（没有太多用户操作，保证吞吐量和周转时间即可）
        >   - 先来先服务，FCFS，非抢占，按请求顺序调度。不利于短作业。
        >   - 短作业优先。非抢占，但长作业可能被接连不断的短作业饿死。
        >   - 最短剩余时间优先。抢占式。
        > - 对于交互式系统（需要快速响应用户操作）：
        >   - 轮转调度。使用CPU时间片轮转，但是进程不断切换，开销较大。
        >   - 优先级调度。为了防止优先级低的进程饿死，可以不断提升其优先级。
        >   - 多级队列。每个队列时间片长度1，2，4，8... 若程序在上一个队列未结束，则转到下一队列。
        > - 在Linux中，实时进程优先级最高，会抢占普通进程优先执行。而普通进程使用公平共享调度（CFS），根据NI值设定优先级，分配的不是时间片，而是CPU使用比，按比例获取CPU使用时间。

    - 20）[中断、异常、陷阱和系统调用]
        > - 中断是由外部事件导致并且它发生的时间是不可预测的，这一点和陷阱不同。外部事件主要是指时钟中断（执行时间足够长，CPU切换到另一进程），硬件中断（例如等待用户IO）等。
        > - 异常就是程序执行过程中的异常行为。比如除零异常，缓冲区溢出异常等。异常是在CPU执行指令时本身出现的问题，比如除数为零而出现的除零异常。异常的产生表示程序设计不合理，所以在编程的时候要尽量避免异常的产生。
        > - 陷阱指令可以使执行流程从用户态陷入内核并把控制权转移给操作系统，使得用户程序可以调用内核函数和使用硬件从而获得操作系统所提供的服务，比如用视频软件放一个电影，视频软件就发出陷阱使用显示器和声卡从而访问硬件。

    - 21）[进程、进程组、会话关系](https://www.cnblogs.com/vamei/archive/2012/10/07/2713023.html)
        > - 进程组是一组相关进程的集合，会话是一组相关进程组的集合。一个进程会有如下ID：PID：进程的唯一标识。PPID：父进程ID， PGID：进程组ID， SID：会话ID。默认情况下，子进程和父进程拥有相同的PID和SID。
        > - 当有新的用户登录Linux时，登录进程会为这个用户创建一个会话。用户的登录shell就是会话的首进程。会话的首进程ID会作为整个会话的ID。会话是一个或多个进程组的集合，囊括了登录用户的所有活动。

    - 22）多线程和多进程如何选择
        > - 多进程可以使得系统鲁棒性更高，出错的时候容易找到错误的地方，而且不影响别的进程。多线程可以进行快速创建和数据共享，进程创建的开销很大，上下文切换开销也稍微大一些，频繁创建进程去响应服务器的请求会造成极大的开销，而且会增加响应时间，所以在进行服务器响应的时候会采用多线程。如果是多核处理用多线程。

- **2.并发和死锁**
    - 1）[什么是条件变量？信号量？](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#12-%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%94%AF%E6%8C%81)
        > 信号量：用于进程间传递信号的一个整数值。只有三种操作：初始化、增加（加锁）、减小（解锁）。
        > 互斥量：类似二元信号量，但是加锁和解锁的只能为同一个进程。
        > 条件变量：用于阻塞进程或者线程，直到条件为真。

    - 2）[死锁条件](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#21-%E6%AD%BB%E9%94%81%E7%9A%84%E6%9D%A1%E4%BB%B6)，解决死锁的方法？（[死锁预防](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#22-%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2)、[死锁避免](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#23-%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D)、[死锁检测](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#24-%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B)）
        > - 条件：互斥（资源只能被一个进程使用）、占有和等待、不可抢占、循环等待。
        > - 预防：即在程序运行前做预防。方法：破坏互斥条件（不太现实）、破坏占有和等待条件（进程开始前一次请求所需的全部资源、可能造成浪费）、破坏不可抢占条件（会混乱）、破坏循环等待（按规定顺序请求资源，但不能令所有人都满意）。
        > - 死锁避免：需要提前知道将来进程对资源的请求情况，通过预先计算、确保不会到达死锁点。
        > - 死锁检测和恢复：并不能保证防止死锁，是否死锁要取决于将来同意请求的次序，它所做的一切是确定当前是否存在死锁，然后采取恢复。恢复：取消所有死锁进程、回滚每个死锁进程到前面定义的某些检测点、连续取消死锁进程直到不再存在死锁。

    - 3）互斥和同步？（互斥是对资源独占访问，同步是在互斥基础上通过其它机制实现对资源有序访问）

    - 4）互斥量和信号量的区别？（一个互斥一个同步、值的区别、加锁解锁的线程）
        > - 信号量：多线程同步使用的；一个线程完成某个动作后通过信号告诉别的线程，别的线程才可以执行某些动作；
        > - 互斥量：多线程互斥使用的；一个线程占用某个资源，那么别的线程就无法访问，直到该线程离开，其他线程才可以访问该资源；

    - 5）自旋锁和互斥锁的区别？（失败后的表现，一个忙等一个睡眠）
        > - 自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是 否该自旋锁的保持者已经释放了锁，"自旋"一词就是因此而得名。自旋锁就主要用在临界区持锁时间非常短且CPU资源不紧张的情况下，自旋锁一般用于多核的服务器。
        > - 互斥锁：线程会从sleep（加锁）——>running（解锁），过程中有上下文的切换，cpu的抢占，信号的发送等开销。但不会持续占有CPU。

- **3.内存管理**
    - 1）[分页](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#3%E5%88%86%E9%A1%B5)（一个进程可以占据多个页，不要求连续，仅最后一页存在内部碎片；[分页中的地址转换](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#31-%E5%88%86%E9%A1%B5%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2)）
        > 由程序产生的虚拟地址先送到MMU，然后MMU根据页表将虚拟地址映射到物理地址。虚拟地址中的内存分块成为页面（page），物理内存中的地址单元成为页框（page frame）。大小通常一样，内存和磁盘间的交换总是以整个页面为单元进行。

    - 2）缺页中断
        > 当软件试图访问已映射在虚拟地址空间中，但是目前并未被加载在物理内存中的一个分页时，由中央处理器的内存管理单元所发出的中断。

    - 3）分段：
        > 当只使用分页时，当有多个动态增加的页表时，一个表可能会和另一个表发生碰撞。所以提供了一种 称为段的地址空间。段的大小是可变的。每个进程都有一个唯一的段表。分段有助于实现保护与共享机制。由于每个段表项包括一个长度和一个基地址，因而程序不会不经意地访问超出该段的内存单元。

    - 4）[缓冲区溢出是什么？会造成什么危害呢？出现原因是什么？](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#51-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA)
        > 缓冲区溢出是指输入到一个缓冲区或者数据保存区域的数据量超过了其容量，从而导致覆盖了其它区域数据的状况。

    - 7）[虚拟内存](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98)（内存管理单元(MMU)：CPU中的一个模块，可以将虚拟地址转换成实际物理地址）
        + 虚拟内存的作用？（程序可以比实际物理内存更大、程序不必完全载入内存即可运行，因此活动进程数更多）
        + 基于[分页](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#1-%E5%88%86%E9%A1%B5)的实现（和不使用虚拟内存相比，页表中多了2个位，一位表示页是否修改，一位表示页是否在内存中、[两级分页系统](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#13-%E4%B8%A4%E7%BA%A7%E5%88%86%E9%A1%B5%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2)）
        + [TLB？](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#15-%E8%BD%AC%E6%8D%A2%E6%A3%80%E6%B5%8B%E7%BC%93%E5%86%B2%E5%8C%BAtlb)（加速页表的访问）
        + 基于[分段](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#2-%E5%88%86%E6%AE%B5)的实现（和不使用虚拟内存相比，段表中多了2个位，一位表示段是否修改，一位表示段是否在内存中）
        + 内存保护（分段有助于内存保护，段表中段的长度描述了段的区域，公共代码可以作为一个段被相同程序的多个进程共享）
        + 基于[段页式](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#3-%E6%AE%B5%E9%A1%B5%E5%BC%8F)的实现
            * 分段对程序员可见、分页对程序员透明
            * 分段有助于扩展性与内存保护、分页有助于消除外部碎片
        + 页面置换算法（目的是尽可能降低缺页错误）：
            > - 最优页面置换算法：只是理论上的算法，很难预测一个页面将来是否会被访问。
            > - 最近最久未使用：LRU。根据过去使用情况，将最近最久未使用的页表换出。
            > - 最近未使用：NRU，每个页面两个状态位R和M，被访问是R=1，被修改时M=1。R位定时清零。优先换出R=0,M=1的脏页。因为R=1的会频繁使用。
            > - 先进先出：FIFO，队列。
            > - 第二次机会：需要换出时不是直接换，而是将其R位由1变0，一旦中途被读取到，则再将R=1。
            > - 时钟（像是timing wheel?）：使用一个环形链表实现。

        + [驻留集](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#44-%E9%A9%BB%E7%95%99%E9%9B%86%E7%AE%A1%E7%90%86)（分配给每个进程的内存大小）管理
            * 驻留集越小，获得进程越多，缺页越高；驻留集越大，活动进程越小，太多时缺页率无明显变化
            * 分配策略与置换范围（固定分配、可变分配、局部置换、全局置换，不存在固定分配全局置换）
        + [清除（写回）策略](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#45-%E6%B8%85%E9%99%A4%E7%AD%96%E7%95%A5)
- **4.I/O与磁盘调度**
    + 1）[DMA？](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#5%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E5%AD%98%E5%8F%96dma)
    + 2）[I/O缓冲？](../操作系统/操作系统.md#1io缓冲)（输入请求发出之前执行输入，输出请求发出一段时间后才执行输出）
    - 3）[磁盘调度算法](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#22-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95)（FIFO、优先级、SSTF、SCAN、C-SCAN、N-step-SCAN）
* **二.Linux**
- **1.进程线程**
    + 1）[C程序的存储空间布局](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#3c%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80)
        > - 正文段（.text段）：这是由CPU执行的机器指令部分
        > - 初始化数据段（.data段）：通常将它称作数据段，包括函数外的赋初值的全局变量、函数内的赋初值的静态变量
        > - 未初始化数据段（.bss段）：通常将它称作bss段。内核将此段中的数据初始化为0或者空指针,包括函数外的未赋初值的全局变量、函数内的未赋初值的静态变量
        > - 栈：临时变量以及每次函数调用时所需要保存的信息都存放在此段中
        > - 堆：通常在堆中进行动态存储分配


    + 2）[fork vfork clone](temp/进程线程.md#1forkvforkclone)
        > - fork: fork创造的子进程是父进程的完整副本，复制了父亲进程的资源，包括内存的内容、task_struct（其实就是PCB，包括进程状态，调度信息，标识符、通信IPC有关信息、文件、CPU上下文等）内容.父子两个进程的pid不同，堆栈和数据资源都是完全的复制。

        > - vfork: vfork创建的子进程与父进程共享数据段,而且由vfork()创建的子进程将先于父进程运行。在子进程退出或开始新程序之前，内核保证了父进程处于阻塞状态。内核连子进程的虚拟地址空间结构也不创建了，直接共享了父进程的虚拟空间，当然了，这种做法就顺水推舟的共享了父进程的物理空间。
        > - clone: 可以让你有选择性的继承父进程的资源，你可以选择想vfork一样和父进程共享一个虚存空间，从而使创造的是线程，你也可以不和父进程共享，你甚至可以选择创造出来的进程和父进程不再是父子关系，而是兄弟关系。

    + 3） 关于fork.
        > 其实在复制过程中，linux采用了写时复制的策略。子进程复制了父进程的task_struct，系统堆栈空间和页面表，这意味着上面的程序，我们没有执行count++前，其实子进程和父进程的count指向的是同一块内存。而当子进程改变了变量时候（即对变量进行了写操作），会通过copy_on_write的手段为所涉及的页面建立一个新的副本。
    <!-- + 3）[Linux性能及调优指南：进程管理](http://blog.jobbole.com/105135/) -->
    + 4）Linux 进程管理
        > - 每个进程有唯一的 pid。使用 ps -l 命令列出当前 shell 创建的进程。
        > - 当Linux启动的时候，init 是系统创建的第一个进程，这一进程会一直存在，直到我们关闭计算机。所有其他的进程都是由 init 进程衍生出来的。实际上相当于有一个以 init 进程为根的进程树。
        > - 工作管理的一些命令：
        >   - ps axjf ，查看所有进程的层次关系
        >   - & 将命令放到后台执行。
        >   - [ctrl]+z 将当前工作放到后台中暂停。
        >   - 查看目前后台工作状态：jobs，-l ：同时列出PID的号码。
        >   - 拿到前台处理：fg %jobnumber。
        >   - kill -1 重新加载、-9 立刻删除、-15 正常终止。监控进程变化：top.

    + 4）Linux守护进程启动方法
        > "守护进程"（daemon）就是一直在后台运行的进程（daemon）。先将其转为后台任务，ctrl+z，然后bg命令，但是仍然不保险，因为进程一旦与标准IO有交互就会挂掉。应该启动时就加 & 符号并且加上 nohup命令，这样该进程不会接受 SIGHUP 信号，并且不能接受任何输入，将输出重定向到 nohup.out

    + 5）[如何实现守护进程](temp/进程线程.md#1如何实现守护进程)
        > - 要实现守护进程，需要将它从启动它的父进程的运行环境中隔离开来。
        > - 大致步骤为：创建子进程，父进程退出（子进程继承了父进程的会话、进程组、控制终端等信息）。调用setsid函数，创建一个新会话，使当前进程脱离原会话的控制，使当前进程脱离原进程组的控制，使当前进程脱离原控制终端的控制。改变当前目录为根目录，直接调用chdir函数。重设文件权限掩码。关闭文件描述符。

    + 6）[main函数启动之前](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#11-main%E5%87%BD%E6%95%B0)
        > 当内核通过exec函数执行 C 程序、在调用main之前先调用一个特殊的启动例程。可执行程序文件将此启动例程指定为程序的起始地址（这是由链接器设置的，而链接器由C编译器调用），启动例程从内核取得命令行参数和环境变量值，为调用main函数做好安排，启动例程使得从main返回后立即调用exit函数。

    + 7）[exit、\_exit、\_Exit](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#1%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E7%BB%88%E6%AD%A2)
        > _exit和_Exit函数：立即进入内核。exit函数：先执行一些清理处理，然后进入内核


    + 8）[线程数量的限制](temp/进程线程.md#1线程数量的限制)
        > 线程的数量取决于线程栈空间的大小（可以使用ulimit -s查看栈空间大小），一般是8M。32位Linux下用户空间是3G，因此可创建的线程数量为3G/stack_size，但是理论上除了栈空间每个线程还有线程控制块的开销，所以实际值会小一些。

    + 9）[进程数量的限制](temp/进程线程.md#2进程数量的限制)
        > 理论上系统中最大的进程数量是8180/2=4090。linux内核通过进程标识符PID来标识进程，为了与老版本的Unix或者Linux兼容，PID的最大值默认设置为32768。

    + 10）[信号](temp/信号.md#1信号)
            > - 信号处理，使用 sigaction 函数。
            > - 常见信号如：SIGHUP 挂起进程，SIGINT终止进程，SIGKILL杀掉进程，SIGTOP停止进程，SIGCONT继续运行停止的进程。

    + 11）线程终止的方法？
        * [pthread_exit](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#5pthread_exit%E5%87%BD%E6%95%B0)（主线程调用了`pthread_exit`对其它线程有什么影响？）
        * 线程执行的函数`return`
        * 被同一进程的其它线程调用[pthread_cancel取消线程](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#7pthread_cancel%E5%87%BD%E6%95%B0)
        * 进程main函数`return`或任何线程调用了`exit`、`_Exit`、`exit`
    + 12）[线程与信号](temp/信号.md#2线程与信号)
        > 进程内内所有线程共享对信号的处理函数。对于发送给进程的信号，内核会任选一个线程来执行信号处理函数，执行完后，会将其从挂起信号队列中去除，其他线程不会对一个信号重复响应。可以针对进程中的某个线程发送信号，那么只有该线程能响应，执行相应的信号处理函数。

    <!-- + 13）[正确使用waitpid处理终止的子进程](https://github.com/arkingc/note/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B71.md#12-%E4%BD%BF%E7%94%A8waitpid%E7%89%88sig_chld%E5%87%BD%E6%95%B0%E5%A4%84%E7%90%86%E5%AD%90%E8%BF%9B%E7%A8%8Bsigchld%E4%BF%A1%E5%8F%B7) -->
        

- **2.并发**
    + 1）Linux上分析死锁的简单方法
        > 使用 gdb。在gcc编译程序时加上gcc -g 表示调试。当出现死锁时，使用 pstack 查看进程的函数调用堆栈，可以看到哪些线程一直在等锁。

    + 2）进程间通信的主要方式（[管道](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#1%E7%AE%A1%E9%81%93)、[FIFO](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#3fifo)、信号、[消息队列](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#5%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97)、[共享内存](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#7%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8)、[信号量](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#8posix%E4%BF%A1%E5%8F%B7%E9%87%8F)、套接字）
    + 3）[线程间同步的主要方式](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#2%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5)（互斥量、读写锁、条件变量、自旋锁、屏障）
    + 4）Linux内核同步机制
        > - 同步是指用于实现控制多个进程按照一定的规则或顺序访问某些系统资源的机制。造成并发的原因：中断处理、内核态抢占、多处理器的并发。采用同步机制的目的就是避免多个进程并发并发访问同一临界资源。 
        > - 1）禁用中断（访问临界资源时禁用中断）（2）自旋锁(缺点是忙等)（3）信号量机制（semaphore）

- **3.文件系统**
    + 1）[Linux中的文件类型](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#2%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B)
        > 普通(一般)文件、目录文件、块特殊文件、字符特殊文件、FIFO命名管道、套接字、符号链接。

    + 2）Linux有哪几种设备？（字符设备与块设备，[mknod系统调用](https://blog.csdn.net/lqp276/article/details/53502992)用来创建设备文件）
    + 3）[如何唯一标识一个设备？](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#13%E8%AE%BE%E5%A4%87%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6)（主设备号和次设备号）
    + 4）[文件描述符的个数](https://blog.csdn.net/yetyongjin/article/details/7476860)
        > ulimit -n ,查看用户级限制,每一个用户登录后执行的程序占用文件描述符的总数不能超过这个限制，可以通过修改配置文件进行修改。 系统级限制：它是限制所有用户打开文件描述符的总和，sysctl -a 什么的命令查看。

    + 5）Linux 同步文件到其他主机
        > - scp: 速度较慢，但保证安全
        > - rsync: 差异化传输rsync使用所谓的“rsync算法”来使本地和远程两个主机之间的文件达到同步，这个算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。

- **4.I/O**
    + 1）5种I/O模型（[总览](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#%E5%85%AB%E9%AB%98%E7%BA%A7io)）
        > 同步I/O （阻塞、非阻塞、I/O复用、信号），异步I/O。
    + 2）[如何理解阻塞非阻塞与同步异步的区别？](temp/IO.md#2如何理解阻塞非阻塞与同步异步的区别)
        > - __同步和异步关注的是消息通讯机制__，同步是就是由调用者主动等待这个调用的结果，异步是是在调用发出后，调用者立刻返回，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。（阻塞和非阻塞都属于同步。）
        > - __阻塞和非阻塞关注的是程序在等待调用结果时的状态__。阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

    + 3）文件读写使用的系统调用：[open](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#21-%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6)、[close](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#23-%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6)、[lseek](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#24-%E5%AE%9A%E4%BD%8D%E8%AF%BB%E5%86%99%E4%BD%8D%E7%BD%AE)、[read](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#25-%E6%96%87%E4%BB%B6%E8%AF%BB)、[write](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#26-%E6%96%87%E4%BB%B6%E5%86%99)

    + 4）[sync、fsync、fdatasync？](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#5%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5)
        > - UNIX操作系统在内核中设有缓冲区高速缓存或页高速缓存，大多数磁盘 I/O 都通过缓冲区进行。当我们想文件写入数据时，内核通常都先将数据复制到缓冲区中，然后排入队列，晚些时候再写入磁盘。这种方式称为延迟写。可以调用sync、fsync或fdatasync来显式的将所有延迟写的数据块写回磁盘.
        >   - sync，将所有修改过的块缓冲区排入写队列，然后返回；它并不等待实际写磁盘操作结束。
        >   - fsync，等待写磁盘操作结束才返回。
        >   - fdatasync，待写磁盘操作结束才返回。只影响文件的数据部分（fsync会同时更新文件的属性）
        
- **5.内存管理[以下均以32位系统来说]**
    + 1）[简述 Linux 内存管理](https://blog.csdn.net/hustyangju/article/details/46330259)
        > - 内存分为内核态和用户态，大小比例为1GB : 3GB。内核态内存由所有进程共享。
        > - 用户态内存分为：代码段text、数据段data、BSS段（未初始化的全局变量）、堆、栈。
        > - 内核态内存分为：
        > - Linux操作系统采用虚拟内存管理技术，使得每个进程都有各自互不干涉的进程地址空间。该空间是块大小为4G的线性虚拟空间，用户所看到和接触到的都是该虚拟地址，无法看到实际的物理内存地址。同时使得进程可以使用比实际物理内存更大的内存空间。
        > - 地址映射过程为 逻辑地址->线性地址->物理地址。逻辑地址经段机制转化成线性地址；线性地址又经过页机制转化为物理地址。在Linux中的逻辑地址等于线性地址,Linux系统虽然保留了段机制，但是将所有程序的段地址都定死为0-4G，所以虽然逻辑地址和线性地址是两种不同的地址空间，但在Linux中逻辑地址就等于线性地址，它们的值是一样的。

    + 2）Linux 内核内存模型

    + 4）[什么是 TLB（快表）](https://blog.csdn.net/njuitjf/article/details/23251083)？
        > 页表一般都很大，并且存放在内存中，所以处理器引入MMU后，读取指令、数据需要访问两次内存：首先通过查询页表得到物理地址，然后访问该物理地址读取指令、数据。为了减少因为MMU导致的处理器性能下降，引入了TLB，TLB是Translation Lookaside Buffer的简称（位于CPU中），可翻译为“地址转换后援缓冲器”，也可简称为“快表”。简单地说，TLB就是页表的Cache，其中存储了当前最可能被访问到的页表项，其内容是部分页表项的一个副本。只有在TLB无法完成地址翻译任务时，才会到内存中查询页表，这样就减少了页表查询导致的处理器性能下降。（计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决）

    + 5）内部碎片和外部碎片
        > - __内部碎片__：内部碎片是已经被分配出去（能明确指出属于哪个进程）的内存空间大于请求所需的内存空间，不能被利用的内存空间就是内部碎片。为了有效的利用内存，使内存产生更少的碎片，要对内存分页，内存以页为单位来使用，最后一页往往装不满，于是形成了内部碎片。由于被装入的数据块小于分区大小，从而导致分区内部有空间浪费，这种现象成为内部碎片。

        > - __外部碎片__：外部碎片是指还没有分配出去（不属于任何进程），但是由于大小而无法分配给申请内存空间的新进程的内存空闲块。频繁的分配与回收物理页面会导致大量的、连续且小的页面块夹杂在已分配的页面中间，就会产生外部碎片。

        > - Linux采用伙伴系统解决外部碎片的问题，采用slab解决内部碎片的问题

    + 6）[Linux内核伙伴系统](temp/内存管理.md#二伙伴系统)
        > - 系统使用内存时倾向于分配连续的内存块，因为分配连续内存时，页表不需要更改，因此能降低TLB的刷新率。频繁地申请和释放不同大小的连续页框，必然导致在已分配页框的内存块中分散了许多小块的空闲页框。这样，即使这些页框是空闲的，其他需要分配连续页框的应用也很难得到满足。
        > - __伙伴算法__：把所有的空闲页框分组为11个块链表，每个块链表分别包含大小为1，2，4，8，16，32，64，128，256，512和1024个连续页框的页框块。最大可以申请1024个连续页框，对应4MB大小的连续内存。每个页框块的第一个页框的物理地址是该块大小的整数倍。
        > - 假设要申请一个256个页框的块，先从256个页框的链表中查找空闲块，如果没有，就去512个页框的链表中找，找到了则将页框块分为2个256个页框的块，一个分配给应用，另外一个移到256个页框的链表中。如果512个页框的链表中仍没有空闲块，继续向1024个页框的链表查找，如果仍然没有，则返回错误。页框块在释放时，会主动将两个连续的页框块合并为一个较大的页框块。

    + 7）[slab分配器](temp/内存管理.md#三slab分配器)
        > - Linux中使用slab来解决小对象的分配：slab分配器是基于对象进行管理的，相同类型的对象归为一类(如进程描述符就是一类)，每当要申请这样一个对象，slab分配器就从一个slab列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存在该列表中，而不是直接返回给伙伴系统，从而避免这些内碎片。slab分配器并不丢弃已分配的对象，而是释放并把它们保存在内存中。当以后又要请求新的对象时，就可以从内存直接获取而不用重复初始化。 Slab将页面（来自于伙伴关系管理的空闲页面链表）撕碎成众多小内存块以供分配。

    + 8）[内核内存分配vmalloc、kmalloc、get_free_pages()](temp/内存管理.md#1内核内存分配)
        > - __kmalloc__ 一般来说内核程序中对小于一页的小块内存的请求才通过Slab分配器提供的接口Kmalloc来完成。从内核内存分配的角度来讲，kmalloc可被看成是get_free_page（s）的一个有效补充，内存分配粒度更灵活了。

        > - kmalloc()和__get_free_pages()函数申请的内存位于物理内存的映射区域，而且在物理上也是连续的，它们与真实的物理地址只有一个固定的偏移，因此存在简单的线性关系

        > - __vmalloc__： 伙伴关系只是减轻了外部分片，但并未彻底消除。所以避免外部分片的最终思路还是落到了如何利用不连续的内存块组合成“看起来很大的内存块”——这里的情况很类似于用户空间分配虚拟内存，内存逻辑上连续，其实映射到并不一定连续的物理内存上。Linux内核借用了这个技术，允许内核程序在内核地址空间中分配虚拟地址，同样也利用页表（内核页表）将虚拟地址映射到分散的内存页上。以此完美地解决了内核内存使用中的外部分片问题。内核提供vmalloc函数分配内核虚拟内存，该函数不同于kmalloc，它可以分配较Kmalloc大得多的内存空间（可远大于128K，但必须是页大小的倍数），但相比Kmalloc来说,Vmalloc需要对内核虚拟地址进行重映射，必须更新内核页表，因此分配效率上要低一些（用空间换时间）。

    + 9）用户内存分配 malloc 所涉及的系统调用有哪些？
        > - vmalloc、kmalloc 是在内核中分配内存，不同于malloc在用户空间中分配，malloc利用堆动态分配，实际上是调用brk()系统调用。brk()会通过一系列系统调用获得指向一块大小合适的空闲线性区的 vma 指针，并初始化 vma 结构中的各个字段。在没有设置VM_LOCKED标志的情况下（默认情况），它不会立刻为该线性区分配物理页框，而是一直将分配物理内存的工作进行延迟，直至发生缺页异常。

    + 10）Linux 内存映射 mmap 原理
        > - mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系.实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。
        > - mmap除了可以减少read,write等系统调用以外，还可以减少内存的拷贝次数，比如在read调用时，一个完整的流程是操作系统读磁盘文件到页缓存，再从页缓存将数据拷贝到read传递的buffer里，而如果使用mmap之后，操作系统只需要将磁盘读到页缓存，然后用户就可以直接通过指针的方式操作mmap映射的内存，减少了从内核态到用户态的数据拷贝。


- **6.其它**
    + 1）[Linux系统调用](http://gityuan.com/2016/05/21/syscall/)
        > - syscall。内核提供用户空间程序与内核空间进行交互的一套标准接口，这些接口让用户态程序能受限访问硬件设备，比如申请系统资源，操作设备读写，创建新进程等。 用户空间通过向内核空间发出Syscall，产生软中断，从而让程序陷入内核态，执行相应的操作。

    + 2）[Linux如何实现系统调用？](temp/系统调用.md#1linux通过什么方式实现系统调用)
        > - 通过软件中断实现。首先，用户程序为系统调用设置参数，其中的一个参数是系统调用编号。参数设置完成后，程序执行“系统调用”指令。x86系统上的软中断是由int $0x80产生。这个指令会导致一个异常：产生一个事件，这个事件会导致处理器切换到内核态并跳转到一个新的地址，并开始执行那里的异常处理程序，此时的异常处理程序就是系统调用程序。

    + 3）[Linux中的软中断和工作队列的作用？](temp/进程线程.md#1linux中的软中断和工作队列的作用)
        > - 软中断一般是“可延迟函数”的总称，它不能睡眠、不能阻塞，处于中断上下文，不能进行进程切换，软中断不能被自己打断，只能被硬件中断打断，可以并发运行在多个cpu上，所以软中断必须设计为可重入函数（允许多个cpu同时操作），因此也需要自旋锁来保护其数据结构
        > - 工作队列中的函数处于进程上下文中，可以睡眠、阻塞。能够在不同进程间切换，以完成不同的工作

    + 4）Linux系统中的动态库和静态库
        > - 二者的不同点在于代码被载入的时刻不同。静态库的代码在编译过程中已经被载入可执行程序,因此体积比较大。动态库(共享库)的代码在可执行程序运行时才载入内存，在编译过程中仅简单的引用，因此代码体积比较小。静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库。动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在。

    + 5）Linux Core Dump理解
        >   Coredump叫做核心转储，它是进程运行时在突然崩溃的那一刻的一个内存快照。操作系统在程序发生异常而异常在进程内部又没有被捕获的情况下，会把进程此刻内存、寄存器状态、运行堆栈等信息转储保存在一个文件里。原因：内存访问越界，由于使用错误的下标，导致数组访问越界，搜索字符串时，依靠字符串结束符来判断字符串是否结束，但是字符串没有正常的使用结束符。线程程序使用了线程不安全的函数。多线程读写的数据未加锁保护。非法指针。堆栈溢出（大局部变量）。

    <!-- + 6）[Linux Shell管道命令与重定向命令的区别](http://blog.jobbole.com/93132/)
    + 7）[ioctl函数理解](http://www.cnblogs.com/li-hao/archive/2011/12/22/2297687.html) -->
    + 8）[gdb简单使用](https://blog.csdn.net/gatieme/article/details/51671430)
        > - 在用 gcc 编译程序时使用 -g 参数： `gcc -g main.c`
        > - 交互参数： run 运行、continue、继续执行到下个断点、next单步不进入、step单步进入、until退出循环、call 函数（参数），调用程序中函数。
        > - 断点设置： break n，在第n行设置断点，delete、enable、disable + 行号，设置断点。
        > - 查看代码：list
        > - gdb 也常用来作多线程调试，info threads 显示当前可调试的所有线程,thread ID 切换当前调试的线程为指定ID的线程,break thread_test.c:123 thread all 在所有线程中相应的行上设置断点,thread apply all command 让所有被调试线程执行GDB命令command。set scheduler-locking on,只有当前被调试程序会执行
        > - 也可以用来调试 core dump文件，会显示 生成此core文件的程序名，中止此程序的信号等等。使用where查看堆栈调用信息，从而定位到在哪里发生了 core dump。

    + 10）库函数和系统调用的区别
        > - 库函数调用通常用于应用程序中对一般文件的访问，库函数调用是系统无关的，因此移植性好。库函数的实现方式，一般都是对系统调用的再次封装。系统调用运行在内核模式，库函数运行在用户模式，但库函数一般都会伴随着系统调用。

    + 11）read 和 fread 的区别
        > - fread返回的是一个FILE结构指针，而read返回的是一个int的文件号
        > - fopen/fread是C标准的库函数，操作的对象是： file stream. open/read 是和操作系统有关的系统调用。操作的对象是： “file descriptor”

